<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<script type="text/javascript">
		function Person(){ //构造函数
			Person.prototype.name = 'wyc';  //实例原型
			Person.prototype.age = 22;
			Person.prototype.sayHello = function(){
				alert(this.name);
			}
		}
		
		function Student(){
			
		}
		Student.prototype.name = 'wycscu';
		Student.prototype.age = 23;
		Student.prototype.sayHello = function(){
			alert(this.name);
		}
		
		var p = new Person();
		//1.创建了一个对象
		//2._proto_属性
		//3.将this指向该对象
		//4.执行构造函数
		//5.返回该对象
		
		//alert(Person.prototype === p.__proto__) //true
		//alert(Person.prototype.constructor === Person)  //true
		//p.sayHello(); //wyc
		
		//当访问一个对象的属性的时候，首先在这个对象的本身进行查找
		//找到直接返回这个属性且停止查找。
		//如果没有找到，继续在原型上查找。即_proto_指向的对象
	</script>
	<body>
		<ol>
			<li>原型prototype</li>
			<li>基于原型的继承</li>
			1.Object.create() <br>
			2.原型继承图示
			<li>原型链</li>
		</ol>
		
		<img src="imgs/原型链.png" >
		<img src="imgs/关系图.png" >
		<br>
		每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。
		那么假如我们让原型对象等于另一个类型的实例，结果会怎样？
		显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。
		假如另一个原型又是另一个类型的实例，那么上述关系依然成立。
		如此层层递进，就构成了实例与原型的链条。这就是所谓的原型链的基本概念
	</body>
</html>
